#!/usr/bin/env perl
use strict;
use File::Basename;
use Cwd qw(abs_path);
use File::Temp qw(tempfile);
use Getopt::Long;

BEGIN
{
  use File::Basename;
  unshift(@INC, dirname($0) . "/lib");
}

#
# Preparation
#
my $me;
my $mydir;
$me = basename($0);
$mydir = abs_path(dirname($0));


#
# Support functions
#
sub usage {
  my $code = shift;
  print STDERR <<EOM;
 Usage: $me [options...] module branch >patch.html

     Generate a unified patch from the svnbranch development.
     By default the patch is generated with a context of 10 lines.

     Options are:
     -r|--revision=<rev>: makes patch at revision <rev> of branch
     -p|--previous: makes patch with previous revision of parent
     -s|--short: generated 3 lines of contex
     -l|--long: generated 100 lines of contex
     -w|--whole: generated whole file context 

EOM
}

my $verbose_execute=0;
sub execute {
  my ($cmd, $params) = @_;
  my $result;
  print STDERR $cmd . "\n" if $verbose_execute;
  if (defined($params) && defined($params->{OUTPUT})) {
    if (open(FILE, $cmd . "|")) {
      while(<FILE>) {
	print;
      }
      close(FILE);
      $result = 1;
    }
  } else {
    $result=`$cmd`;
    chomp $result if defined $result;
  }
  return $result;
}
#
# Initialization
#
my $context = 10;
my $opt_previous;
my $opt_revision;
my ($module, $branch, $svnroot);
Getopt::Long::config(qw(no_ignore_case));
usage(1) unless GetOptions('s|short' => sub { $context = 3; },
			   'l|long' => sub { $context = 100; },
			   'w|whole' => sub { $context = 10000; },
			   'p|previous' => \$opt_previous,
			   'r|revision=s' => \$opt_revision,
			   'h|help' => sub { usage(0); });

($module, $branch, $svnroot) = @ARGV;

defined($module)  || die "missing module argument";
defined($branch)  || die "missing branch argument";
defined($svnroot) || die "missing svnroot argument";

#
# main processing
#

# Create diff script
my ($fhtmp, $ftmp) = tempfile("tempXXXXXX", { CLEANUP => 1 });
print $fhtmp <<EOM ;
#!/bin/sh
diff -u -U $context \${1+\"\$\@\"}
EOM
close($fhtmp);

chmod (0755, $ftmp);


$branch = "branches/$branch" unless ($branch eq "trunk" || $branch =~ /^branches\//);
my $this_url="$svnroot/$module/$branch";
my $revision =execute("svn info $this_url | grep 'Last Changed Rev' | awk '{print \$4;}'") || die "cannot get revision for $this_url";
$revision=$opt_revision if defined($opt_revision);
my $parent_branch=execute("svn pg -r $revision svnbranch:parent $this_url") || die "cannot get parent branch";
$parent_branch = "branches/$parent_branch" unless ($parent_branch eq "trunk" || $parent_branch =~ /^branches\//);
my $parent_revision=execute("svn pg -r $revision svnbranch:baseline $this_url")  || die "cannot get baseline";
my $parent_url="$svnroot/$module/$parent_branch";
$parent_revision-- if defined($opt_previous);

execute("svn diff --diff-cmd $ftmp --old=$parent_url\@$parent_revision --new=$this_url\@$revision", { OUTPUT => 1 });

